<?xml version="1.0" encoding="utf-8"?>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-19 Sun 14:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Types</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="um" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel='stylesheet' href='/static/css/style.css' type='text/css'/>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<h1 class='title'>
    <a href='/index.html'>
      <img id='banner' src='/static/img/logo.svg'
           alt='Synechist-trichotomic logo. Designed by Shon Feder'/>
      <span class='title-text'>Synechepedia</span>
    </a>
   </h1>
<div class='nav'>
<ul>
</ul>
</div>
</div>
<div id="content">
<h1 class="title">Types</h1>
<p>
Notes on types, largely, but not exclusively, from the perspective of
type theory.
</p>

<div id="outline-container-org9fe4ba0" class="outline-2">
<h2 id="org9fe4ba0">What are Types?</h2>
<div class="outline-text-2" id="text-org9fe4ba0">
</div>
<div id="outline-container-orgd2e9844" class="outline-3">
<h3 id="orgd2e9844">In &ldquo;Type Theory&rdquo;</h3>
<div class="outline-text-3" id="text-orgd2e9844">
<blockquote>
<p>
In the &ldquo;types as predicates&rdquo; variant of the &ldquo;types as sets&rdquo; approach, types are
taken to be predicates, which therefore denote sets (or some variant thereof,
such as domains). However, many advocates of this view are more proof
theoretically inclined, and hence might resist such denotations. Perhaps the
best known work along this line is Martin-Löf&rsquo;s &ldquo;type theory&rdquo;, which also
provides dependent types, as implemented in Pebble and other languages. (Note
that &ldquo;type theory&rdquo; is not a general theory of types, but rather a specific
intuitionistic logic which provides one specific notion of type).
</p>

<p>
(<a class='org-ref-reference' href="#Programming91typesas">Programming91typesas</a>)
</p>
</blockquote>

<p>
What is the theory of types that is presupposed by the λ-calculus based type
theories?
</p>
</div>

<div id="outline-container-orgd04c047" class="outline-4">
<h4 id="orgd04c047">Genealogy</h4>
<div class="outline-text-4" id="text-orgd04c047">
</div>
<div id="outline-container-orga4dcec2" class="outline-5">
<h5 id="orga4dcec2">re: The Prehistory of Types</h5>
<div class="outline-text-5" id="text-orga4dcec2">
<blockquote>
<p>
In all subsumptions of an object under a concept the representations of the
former must be <b>homogeneous</b> [Gleichartig] with the latter, i.e., the concept
must contain that which is represented in the object that is to be subsumed
under it, for that is just what is meant by the expression &ldquo;an object is
contained under a concept&rdquo;.
</p>

<p>
(<a class='org-ref-reference' href="#kant98_critiq">kant98_critiq</a>, A137/B176)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orge4377eb" class="outline-5">
<h5 id="orge4377eb">re: The History of Types</h5>
<div class="outline-text-5" id="text-orge4377eb">
<p>
Martin-Löf&rsquo;s, in his &ldquo;An intuitionistic theory of types&rdquo;, explicitly traces his
concept of type back to Russel:
</p>

<blockquote>
<p>
Every mathematical object is of a certain kind or <i>type</i>. Better, a mathematical
object is always given together with its type, that is, it is not just an
object, it is an object of a certain type. This may be regarded as a simpler and
at the same time more general formulation of Russel&rsquo;s 1903 <i>doctrine of types</i>,
according to which a type is the range of significance of a propositional
function, because in the theory that I am about to describe every propositional
function will indeed have a type as its domain.
</p>

<p>
(<a class='org-ref-reference' href="#martin1998intuitionistic">martin1998intuitionistic</a>)
</p>
</blockquote>

<p>
Russell&rsquo;s theory of types puts the concept of a propositional <i>function</i> <b>under</b>
the concept of a general proposition (in the sense of conceptually prior to).
</p>

<blockquote>
<p>
Every proposition containing all asserts that some propositional function is
always true; and this means that all values of the said function are true
</p>
</blockquote>

<p>
Then the meaning of quantification is subordinate to the range of <i>valid</i> values
of a function.
</p>

<blockquote>
<p>
Hence we can speak of all of a collection when and only when the collection
forms part or the whole of the range of significance of some propositional
function, the range of significance being defined as the collection of those
arguments for which the function in question is significant, i. e., has a value.
(<a class='org-ref-reference' href="#10.2307/2369948">10.2307/2369948</a>)
</p>
</blockquote>

<p>
Hence, &ldquo;a type is defined as the range of significance of a propositional
function, i.e., as the collection of arguments for which the said function has
values&rdquo; (<a class='org-ref-reference' href="#10.2307/2369948">10.2307/2369948</a>).
</p>

<p>
But what determines the <i>validity</i> of this range? Russell names it &ldquo;logical
homogeneity&rdquo;:
</p>

<blockquote>
<p>
What is essential, as appears from the above discussion, is not finitude, but
what may be called logical homogeneity. This property is to belong to any
collection whose terms are all contained within the range of significance of
some one function. It would always be obvious at a glanice whether a collection
possessed this property or not, if it were not for the concealed ambiguity in
common logical terms such as true and false, which gives an appearance of being
a single function to what is really a conglomeration of many functions with
different ranges of significance.
</p>

<p>
(<a class='org-ref-reference' href="#10.2307/2369948">10.2307/2369948</a>)
</p>
</blockquote>

<p>
<i>Logical homogeneity</i> is a property of <i>collections of terms</i>. A collection of
terms has this property when all the terms are &ldquo;contained within the range of
significance of some one function&rdquo;. A &ldquo;type&rdquo; is then a special case of a
logically homogenius collection of terms: a logically homogenius collection of
terms whose characteristic function is <i>propositional</i> is a <i>type</i>.
</p>

<p>
Of course, this all leaves undecided the really essential and most interesting
question: How is the homogeneity of such collections determined and enforced? By
virtue of what can we say that the terms in such a collection <i>belong</i> together?
And, once we&rsquo;ve determined that belonging together, how do we enforce this?
</p>
</div>
</div>
</div>

<div id="outline-container-org6e2368c" class="outline-4">
<h4 id="org6e2368c">Enforcement: types as marks of belonging-together</h4>
<div class="outline-text-4" id="text-org6e2368c">
<p>
The types of the typed λ-calculi are <i>marks</i>, or <i>indexes</i>, used to enforce a
sense of appropriateness that follows from presumptions of <i>belonging together</i>.
</p>

<p>
This is indeed how types function in the calculi when represented ala Church.
The types mark the λ-terms themselves, being inscribed into each head. These
marks serve as a prophylactic protecting against unwanted applications. This
usage echos the etymon of &rsquo;type&rsquo;:
</p>

<blockquote>
<p>
late 15c., &ldquo;symbol, emblem,&rdquo; from Latin <i>typus</i> &ldquo;figure, image, form, kind,&rdquo;
from Greek <i>typos</i> &ldquo;a blow, dent, impression, mark, effect of a blow; figure in
relief, image, statue; anything wrought of metal or stone; general form,
character; outline, sketch,&rdquo; from root of <i>typtein</i> &ldquo;to strike, beat,&rdquo; from PIE
<i>*tup-</i>, variant of root <i>*(s)teu-</i> (1) &ldquo;to push, stick, knock, beat&rdquo;
(<a href="https://www.etymonline.com/search?q=type">etymonline</a>)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org0a5ba05" class="outline-4">
<h4 id="org0a5ba05">Justification:</h4>
<div class="outline-text-4" id="text-org0a5ba05">
<p>
What justifies such enforcement?
</p>
</div>
</div>
</div>

<div id="outline-container-org11549f3" class="outline-3">
<h3 id="org11549f3">Types as Theories</h3>
<div class="outline-text-3" id="text-org11549f3">
<blockquote>
<p>
The essential insight of the &ldquo;types as algebras&rdquo; notion is that the <i>operations</i>
associated with data are at least as important as the values. Thus, the this
approach generalized from [types as] sets to <i>algebras</i>, which are just sets
with some given operations.
</p>

<p>
(<a class='org-ref-reference' href="#Programming91typesas">Programming91typesas</a>)
</p>
</blockquote>

<p>
Let&rsquo;s lean on the proof-theory side of types-as-propositions and recall (what I
believe to be) a key insight of Gentzen&rsquo;s approach:
</p>

<blockquote>
<p>
To every logical symbol &#x2026; belongs precisely one inference figure which
&rsquo;introduces&rsquo; the symbol - as the terminal symbol of a formula - and one which
&rsquo;eliminates&rsquo; it. &#x2026; The introductions represent, as it were, the &rsquo;definitions&rsquo;
of the symbols concerned, and the eliminations are no more than, in the final
analysis, than the consequences of these definitions. This fact may be expressed
as follows: In eliminating a symbol, we may use the formula with whose terminal
symbol we are dealing only &rsquo;in the sense afforded by the introduction of that
symbol&rsquo;.
</p>

<p>
<a class='org-ref-reference' href="#m.69_gerhar_gentz_german">m.69_gerhar_gentz_german</a>
</p>
</blockquote>

<p>
That is, the meaning of the logical connectives (i.e., the correspondents of the
principle types in the various type theories) is given by their introduction and
elimination rules. From the Curry perspective on typing, I think we can say that
the intro/elim rules are (partial) operations on the sets of derivations in the
lambda calculus (since a set of derivations is a set of programs, which is a set
of proofs, which is the meaning of a proposition according to the perspective of
proof-theoretic semantics). If this is correct, I think we have a perspective
from which we can say that the meaning of the types in our systems are indeed
given by the operations belonging to each type (i.e., the particular sets of
operations which carve out patterns of permitted connections within the sets of
derivations of the lambda calculus).
</p>
</div>
</div>
</div>

<div id="outline-container-org08a7aee" class="outline-2">
<h2 id="org08a7aee"><span class="todo TODO">TODO</span> Notes to process</h2>
<div class="outline-text-2" id="text-org08a7aee">
</div>
<div id="outline-container-org7b878bd" class="outline-3">
<h3 id="org7b878bd">Structuralist view</h3>
<div class="outline-text-3" id="text-org7b878bd">
<p>
Girard advances an existentialist view of logic (and type theory, as a
sub-discipline):
</p>

<blockquote>
<p>
<b>Existence.</b> One can instead contend that [the existence of] objects are
 anterior to their type, seen as an essence. This is the viewpoint of
 <i>subtyping</i>, this is also the viewpoint of ludics: an object may have several
 types, be representative of several essences. Their <i>locativity</i> becomes
 essential.
</p>

<p>
(<a class='org-ref-reference' href="#girard11">girard11</a>)
</p>
</blockquote>

<p>
I suspect that, when cleansed of it&rsquo;s humanist and historicist distortions,
existentialism resolves into a radical structuralism.
</p>

<p>
I further suspect&#x2026;
</p>

<p>
A type system is a functor from types to terms. Parametric types give natural
transformations over functors to simply typed terms. There are also other
important ways of tracing natural transformations between sets of typeable
terms. Subtyping lets us establish and specify some of these and, in fact,
Girard presents polymorphism as a subspecies of subtyping:
</p>

<blockquote>
<p>
Polymorphism is the observation that the same λ-term can admit several types.
</p>

<p>
(<a class='org-ref-reference' href="#girard11">girard11</a>, 135)
</p>
</blockquote>

<p>
The jiggering and exploring of various type systems is all in pursuit of an
ideal sweet spot that will let us prove everything we think we should be able to
while eliminating forms of expression that become unwieldy and undermine our
capacity to reason about the system at all. Type systems also provide an
important <i>interface</i> abstracting over lambda terms. When we reason about terms
of type <code>int -&gt; int</code> we can draw inferences about an infinite class of potential
functions while maintaining a birds eye view.
</p>

<p>
Does it make sense to look for types that range over patterns and structures
that hold between subtypes?
</p>

<p>
From the subtyping view, the addition of linear types expanded the class of
terms our types can provide an interface to, allowing new distinctions (maybe
also allowing terms untypeable in other systems into the domain?).
</p>

<p>
There are types correlating interfaces between systems of types. This is what
Goguen advocates in <a class='org-ref-reference' href="#Programming91typesas">Programming91typesas</a>.
</p>
</div>
</div>

<div id="outline-container-orgeb6df7b" class="outline-3">
<h3 id="orgeb6df7b">A confusion regarding the Curry-Howard analogy</h3>
<div class="outline-text-3" id="text-orgeb6df7b">
<p>
iiuc, \(x : A \simeq x \in A \simeq x \: is \: an \: A\). This level of typing
judgment is required for a simply typed λ-calculus. But simply typed λ-calculus
is only analogous to <i>propsitional logic</i>, so how can we be predicating here?
This is what leads me to suspect type theory would be more easily understood as
an extension of <a href="https://en.wikipedia.org/wiki/Term_logic">term logic</a>.
</p>
</div>
</div>

<div id="outline-container-org89a7717" class="outline-3">
<h3 id="org89a7717">Type Theory as a Normative Discipline</h3>
<div class="outline-text-3" id="text-org89a7717">
<p>
This is merely an extension of the normative theory of logic.
</p>

<p>
Type Theory is a computational model constrained by a logical syntax.
</p>

<blockquote>
<p>
Logical syntax can thus be seen both as a constructive tool, enabling the
formation of (normalizing) typed terms, and as a constraining one, imposing a
<i>custom</i> on pure terms (and their socialization) in order to force termination.
</p>

<p>
(<a class='org-ref-reference' href="#abrusci14_transc">abrusci14_transc</a>)
</p>
</blockquote>
</div>

<div id="outline-container-org7fb98a1" class="outline-4">
<h4 id="org7fb98a1"><span class="todo TODO">TODO</span> Extract Thread from Twitter</h4>
<div class="outline-text-4" id="text-org7fb98a1">
<p>
<h1 class='org-ref-bib-h1'>Bibliography</h1>
<ul class='org-ref-bib'><li><a id="Programming91typesas">[Programming91typesas]</a> <a name="Programming91typesas"></a>Joseph Goguen Programming & Joseph Goguen, Types as Theories, 357-390, in in: Topology and Category Theory in Computer Science, edited by (1991)</li>
<li><a id="kant98_critiq">[kant98_critiq]</a> <a name="kant98_critiq"></a>Kant, Critique of pure reason, Cambridge University Press (1998).</li>
<li><a id="martin1998intuitionistic">[martin1998intuitionistic]</a> <a name="martin1998intuitionistic"></a>Martin-L\"of, An intuitionistic theory of types, <i>Twenty-five years of constructive type theory</i>, <b>36</b>, 127-172 (1998).</li>
<li><a id="10.2307/2369948">[10.2307/2369948]</a> <a name="10.2307/2369948"></a>Bertrand Russell, Mathematical Logic as Based on the Theory of Types, <i>American Journal of Mathematics</i>, <b>30(3)</b>, 222-262 (1908). <a href="http://www.jstor.org/stable/2369948">link</a>.</li>
<li><a id="m.69_gerhar_gentz_german">[m.69_gerhar_gentz_german]</a> <a name="m.69_gerhar_gentz_german"></a>edited by Szabo, The collected papers of Gerhard Gentzen / (translated from the  German)., North-Holland Publishing (1969).</li>
<li><a id="girard11">[girard11]</a> <a name="girard11"></a>Jean-Yves Girard, The blind spot : lectures on logic, European Mathematical Society (2011).</li>
<li><a id="abrusci14_transc">[abrusci14_transc]</a> <a name="abrusci14_transc"></a>Abrusci & Pistone, On Transcendental Syntax: A Kantial Program For Logic?, <i>Unpublishd</i>,  (2014).</li>
</ul>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class='footer'>
Copyright 2019 Shon Feder.<br>
Last updated 2020-04-18 Sat 14:46. <br>
Built with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.4).
</div>
</div>
</body>
</html>
