<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-10-18 Wed 10:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Day 8: Unsure</title>
<meta name="author" content="um" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel='stylesheet' href='/static/css/style.css' type='text/css'/>
</head>
<body>
<div id="preamble" class="status">
<h1 class='title'>
    <a href='/index.html'>
      <img id='banner' src='/static/img/logo.svg'
           alt='Synechist-trichotomic logo. Designed by Shon Feder'/>
      <span class='title-text'>Synechepedia</span>
    </a>
   </h1>
<div class='nav'>
<ul>
</ul>
</div>
</div>
<div id="content" class="content">
<h1 class="title">Day 8: Unsure</h1>
<blockquote>
<p>
The counterpart of abstraction is <i>application</i>.
</p>

<p>
(<a href="#citeproc_bib_item_1">Nederpelt and Geuvers 2014</a>)
</p>
</blockquote>

<p>
I must not neglect application: I cannot abide theory without praxis. And yet, a
properly critical theory should be praxis and application is impossible without
antecedent abstraction. I must keep this tension and problematic in mind,
without letting the lust for palpable production undermine my intention to
cultivate theoretical foundations. <i>Counterparts are clearly not contraries.</i>
</p>
<div id="outline-container-org080a9d5" class="outline-2">
<h2 id="org080a9d5">Today&rsquo;s Progress</h2>
<div class="outline-text-2" id="text-org080a9d5">
</div>
<div id="outline-container-orgdbdc8b2" class="outline-3">
<h3 id="orgdbdc8b2">PLT</h3>
<div class="outline-text-3" id="text-orgdbdc8b2">
</div>
<div id="outline-container-orgb8cade1" class="outline-4">
<h4 id="orgb8cade1">Simplified Themis ABT library</h4>
<div class="outline-text-4" id="text-orgb8cade1">
<p>
Abstract Binding Trees (ABTs) extend abstract syntax trees (ASTs) with logic to
handle variable binding. The motivation is as follows: Nearly every interesting
programming language has some concept of a variable which can be bound and
substituted out. Rather than reimplimenting binding and substitution logic for
every language we implement, we should be able to implement this logic once, and
reuse that in all of our languages. Thus, the ABT abstract data type gives tools
for forming an abstract syntax for representing the structure of our language
that includes a readymade mechanism for dealing with variables.
</p>

<p>
See <a href="https://semantic-domain.blogspot.com/2015/03/abstract-binding-trees.html">Neel Krishnaswami</a>&rsquo;s post on the subject for more details, including notes on
the history of the technique and an example implementation.
</p>

<p>
I have been developing a little ABT library as a side effect of my lambda
calculi implementations in <a href="https://gitlab.com/shonfeder/themis">themis</a>. Prior to today, the ABT library was leaking
some abstraction into the representation of the syntax generated for a
particular language, requiring the user (me) to check and deal with values which
were only needed internally. I plugged that abstraction leak in
<a href="https://gitlab.com/shonfeder/themis/commit/960dc6d314041838a2ae2c6165ae9db48258a7db">commit/960dc6d314041838a2ae2c6165ae9db48258a7db</a>.
</p>
</div>
</div>
<div id="outline-container-orgff5e43e" class="outline-4">
<h4 id="orgff5e43e">λ⟶</h4>
<div class="outline-text-4" id="text-orgff5e43e">
<p>
I finished adding type checking and term finding to the implementing of λ⟶ in
themis with <a href="https://gitlab.com/shonfeder/themis/commit/d06be73862b9d0f4eabb57c102b312fe0cfb323e">commit/d06be73862b9d0f4eabb57c102b312fe0cfb323e</a> . The API for the
<code>Check</code> module is as follows:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span class="org-tree-sitter-hl-faceXkeyword">module</span> <span class="org-tree-sitter-hl-faceXconstructor">Check</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">:</span> <span class="org-tree-sitter-hl-faceXkeyword">sig</span>
  <span class="org-tree-sitter-hl-faceXcomment">(** Check and infer various properties *)</span>

  <span class="org-tree-sitter-hl-faceXkeyword">val</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">infer_type</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">:</span> <span class="org-tree-sitter-hl-faceXconstructor">Derivation</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXconstructor">Ctx</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXconstructor">Term</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXconstructor">Type</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXtype"><span class="org-tree-sitter-hl-faceXtypeXbuiltin">option</span></span>
  <span class="org-tree-sitter-hl-faceXcomment">(** [infer_type ctx term] is [Some type] if [type] can be derived for the</span>
<span class="org-tree-sitter-hl-faceXcomment">      [term] in the given [ctx]. Otherwise, it is [None]. *)</span>

  <span class="org-tree-sitter-hl-faceXkeyword">val</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">infer_term</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">:</span> <span class="org-tree-sitter-hl-faceXconstructor">Derivation</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXconstructor">Ctx</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXconstructor">Type</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXconstructor">Derivation</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">judgment</span> <span class="org-tree-sitter-hl-faceXtype"><span class="org-tree-sitter-hl-faceXtypeXbuiltin">option</span></span>
  <span class="org-tree-sitter-hl-faceXcomment">(** [infer_term ctx type] is [Some term] if [term] can be synthesized to</span>
<span class="org-tree-sitter-hl-faceXcomment">      inhabit the [type] in the given [ctx]. Otherwise, it is [None]. *)</span>

  <span class="org-tree-sitter-hl-faceXkeyword">val</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">typing</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">:</span> <span class="org-tree-sitter-hl-faceXconstructor">Derivation</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">judgment</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype"><span class="org-tree-sitter-hl-faceXtypeXbuiltin">bool</span></span>
  <span class="org-tree-sitter-hl-faceXcomment">(** [typing j] is [true] if a derivation can be found proving the judgment [j].*)</span>

  <span class="org-tree-sitter-hl-faceXkeyword">val</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">well_typed</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">:</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">?</span><span class="org-tree-sitter-hl-faceXproperty">ctx</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">:</span><span class="org-tree-sitter-hl-faceXconstructor">Derivation</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXconstructor">Ctx</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXconstructor">Term</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">-&gt;</span> <span class="org-tree-sitter-hl-faceXconstructor">Derivation</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">.</span><span class="org-tree-sitter-hl-faceXtype">t</span> <span class="org-tree-sitter-hl-faceXtype"><span class="org-tree-sitter-hl-faceXtypeXbuiltin">option</span></span>
  <span class="org-tree-sitter-hl-faceXcomment">(** [well_typed term] is [Some derivation] if a type can inferred for [term]</span>
<span class="org-tree-sitter-hl-faceXcomment">      and a [derivation] can be built demonstrating that the [term] has that</span>
<span class="org-tree-sitter-hl-faceXcomment">      type in the given [ctx].</span>

<span class="org-tree-sitter-hl-faceXcomment">      [ctx] defaults to an empty context. *)</span>
<span class="org-tree-sitter-hl-faceXkeyword">end</span> <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">=</span> <span class="org-tree-sitter-hl-faceXkeyword">struct</span>
</pre>
</div>

<p>
It&rsquo;s not <i>really</i> a reliable implementation of these checks, because I haven&rsquo;t
rigged up the property based tests to &ldquo;verify&rdquo; correctness. But I&rsquo;ve manually
checked that they yield the expected results on select terms in the interpreter
and, most importantly, I feel pretty confident in my understanding of these
algorithms. I&rsquo;m going to postpone tests for their correctness for the sake of
moving on to the implementation of λ2 tomorrow.
</p>

<p>
I also finished reading Chapter 2 of (<a href="#citeproc_bib_item_1">Nederpelt and Geuvers 2014</a>), whence I took my
instruction on the implementation of the above. I&rsquo;m getting started with Chapter
3 tonight.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9c45092" class="outline-2">
<h2 id="org9c45092">Tomorrow&rsquo;s Program</h2>
<div class="outline-text-2" id="text-org9c45092">
</div>
<div id="outline-container-orgd215848" class="outline-3">
<h3 id="orgd215848">PLT</h3>
<div class="outline-text-3" id="text-orgd215848">
</div>
<div id="outline-container-org249bb13" class="outline-4">
<h4 id="org249bb13">Begin implementing λ2</h4>
<div class="outline-text-4" id="text-org249bb13">
<p>
I think I&rsquo;ve learned some lessons from my implementations of λ and λ⟶, and there
are some things I want to do differently as I dig in to λ2 to improve and
expedite the process:
</p>

<ul class="org-ul">
<li>Define the parser and pretty printer first</li>
<li>Write all unit tests using the parser and pretty printer (property based tests
should still generate terms via manipulation of the ABT)</li>
<li>Don&rsquo;t get distracted by premature generalization of the framework and tooling
around the language implementation, just drive forward with the
implementation. After it is done, I&rsquo;ll refactor out common elements with the
other implementations.</li>
</ul>
</div>
</div>
<div id="outline-container-org7c284a6" class="outline-4">
<h4 id="org7c284a6">Finish Chapter 2 of (<a href="#citeproc_bib_item_1">Nederpelt and Geuvers 2014</a>)</h4>
</div>
</div>
</div>
<div id="outline-container-orga1ffe06" class="outline-2">
<h2 id="orga1ffe06">References</h2>
<div class="outline-text-2" id="text-orga1ffe06">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Nederpelt, Rob P., and Herman Geuvers. 2014. <i>Type Theory and Formal Proof: An Introduction</i>. Cambridge University Press.</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class='footer'>
Copyright 2023 Shon Feder.<br>
Last updated 2023-10-18 Wed 10:03. <br>
Built with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1 (<a href="https://orgmode.org">Org</a> mode 9.7).
</div>
</div>
</body>
</html>